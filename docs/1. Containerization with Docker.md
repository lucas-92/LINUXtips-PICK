### Containerization with Docker

```
git clone https://github.com/badtuxx/giropops-senhas
cd giropops-senhas/
echo "FROM cgr.dev/chainguard/python:latest-dev AS builder
WORKDIR /app
COPY . .
RUN pip install --user --no-cache-dir -r requirements.txt

FROM cgr.dev/chainguard/python:latest
WORKDIR /app
COPY --from=builder /home/nonroot/.local/lib/python3.12/site-packages /home/nonroot/.local/lib/python3.12/site-packages
COPY --from=builder /home/nonroot/.local/bin/flask /home/nonroot/.local/bin/flask
COPY . .

ENV PATH=\"/home/nonroot/.local/bin:\$PATH\"
ENTRYPOINT [\"flask\", \"run\", \"--host=0.0.0.0\"]" >> Dockerfile
```

#### Explanation

The containerization process consists of creating a file called “Dockerfile” to create a Docker image. The Dockerfile starts with the ```FROM``` section, there we define what our base image is, which in this project will be a Chainguard Python image, this image was adopted because Chainguard is a company known for secure and minimal container images.
`
FROM cgr.dev/chainguard/python:latest-dev AS builder
`
The `AS builder` part means this is a construction step.

When the container starts, what will be the default directory? We answer this question using `WORKDIR` which in this case is `/app`

Now we have a base image and the default directory, but its empty. To solve this, we will `COPY` everything from app directory called `/giropops-senhas` (The current directory), to our `WORKDIR` directory called `/app`, for do this we will use "COPY period space period": `COPY . .` Its means, copy everything from the current directory "/giropops-senhas" to directory defined in `WORKDIR` "/app".

Now that we have our directory with the necessary files, let's run the command that installs the application requirements: `RUN pip install --user --no-cache-dir -r requirements.txt`.

`pip install` Is a package installer for Python, to install Python packages

`-- user` This option tells pip to install the packages in the user-level directory instead of the system-wide directory. This is useful when you don't have permission to install packages globally or want to avoid modifying the system Python environment.

`--no-cache-dir` This option prevents pip from saving the downloaded packages in its cache. This reduces the size of the Docker image since the cache isn't stored, which is particularly useful in a containerized environment where minimizing image size is important.

`-r requirements.txt` This option tells pip to install all the packages listed in the requirements.txt file. The requirements.txt file is a standard way of specifying a list of Python packages along with their versions.

`FROM` This Dockerfile instruction sets the base image for the Docker image you are building.

`cgr.dev/chainguard/python:latest` This specifies the base image.

`WORKDIR /app` This sets the working directory for any subsequent commands in the Dockerfile. If the directory doesn’t exist, it will be created. All relative paths in following commands will be relative to `/app`.

`COPY --from=builder`: This is a multi-stage build instruction. It copies files from a previous build stage named builder. However, the builder stage itself is not shown in the provided code, but you can assume that it was defined earlier in the Dockerfile or in an external build process.
